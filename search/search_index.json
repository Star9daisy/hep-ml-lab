{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HEP ML Lab (HML)","text":""},{"location":"#introduction","title":"Introduction","text":"<p>HEP-ML-Lab is an end-to-end framework used for research combining high-energy physics phenomenology with machine learning. It covers three main parts: the generation of simulated data, the conversion of data representation, and the application of analysis approaches.</p> <p>With HML, researchers can easily compare the performance between traditional methods and modern machine learning algorithms, and obtain robust and reproducible results.</p> <p>To get started, please check out the documents.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hep-ml-lab\n</code></pre>"},{"location":"#module-overview","title":"Module overview","text":"<ul> <li><code>hml.generators</code>: API of Madgraph5 for simulating colliding events;</li> <li><code>hml.observables</code>: General observables in jet physics;</li> <li><code>hml.representations</code>: Different data structure used to represent an event;</li> <li><code>hml.datasets</code>: Existing datasets and helper classes for creating new datasets;</li> <li><code>hml.approaches</code>: Cuts, trees and networks for classification;</li> <li><code>hml.metrics</code>: Metrics used in classical signal vs background analysis;</li> <li><code>hml.utils</code>: Utility functions.</li> </ul>"},{"location":"#updates","title":"Updates","text":""},{"location":"#v0301","title":"v0.3.0.1","text":"<ul> <li>Fix a bug that Madgraph5 may run into an infinite loop caused by HML keeping   removing py.py file during initialization.</li> <li>Fix nan value not implemented in Fileter.</li> <li>Fix the wrong order of runs when using <code>hml.generators.Madgraph5.runs</code> and   <code>hml.generators.Madgraph5.summary</code>.</li> <li>Fix the typo \"g1\" in quickstart.</li> </ul>"},{"location":"#v030","title":"v0.3.0","text":"<ul> <li>New Madgraph5 API now is closer to the original Madgraph5 CLI.</li> <li>New Observable parsing system makes it easier to use and define new observables.</li> <li>New CutAndCout and BoostedDecisionTree in Keras style.</li> </ul>"},{"location":"#v022","title":"v0.2.2","text":"<ul> <li>Change output structure of <code>hml.generators.Madgraph5</code> to ensure reproducibility.</li> <li>Refactor <code>hml.generators.Madgraph5</code> and <code>hml.generators.MG5Run</code> to make   them more robust.</li> </ul>"},{"location":"#v021","title":"v0.2.1","text":"<ul> <li>Add <code>summary</code> to <code>hml.generators.Madgraph5</code> to print a summary of all run.</li> <li>Add <code>remove</code> to <code>hml.generators.Madgraph5</code> to remove a run.</li> <li>Add <code>clean</code> to <code>hml.generators.Madgraph5</code> to remove the output directory.</li> </ul>"},{"location":"api-reference/hml.datasets/","title":"hml.datasets","text":""},{"location":"api-reference/hml.datasets/#hml.datasets.Dataset","title":"Dataset","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for datasets used in HML.</p> <p>This protocol follows the same style as the <code>sklearn.utils.Bunch</code> class and is simpified to quickly save and load datasets.</p> Source code in <code>hml/datasets.py</code> <pre><code>class Dataset(Protocol):\n\"\"\"A protocol for datasets used in HML.\n    This protocol follows the same style as the `sklearn.utils.Bunch` class and\n    is simpified to quickly save and load datasets.\n    \"\"\"\n@property\ndef samples(self) -&gt; np.ndarray:\n\"\"\"The samples (data points) of the dataset.\"\"\"\n...\n@property\ndef targets(self) -&gt; np.ndarray:\n\"\"\"The targets (integer labels) of the dataset.\"\"\"\n...\n@property\ndef description(self) -&gt; str:\n\"\"\"The description of the dataset.\"\"\"\n...\ndef save(self, filepath: PathLike, overwrite: bool) -&gt; None:\n\"\"\"Save the dataset to a .npz file.\n        It is required to save `_type` to distinguish between different datasets\n        and load them correctly via `load_dataset` method.\n        \"\"\"\n...\n@classmethod\ndef load(cls, filepath: PathLike) -&gt; Dataset:\n\"\"\"Load the dataset from a .npz file.\"\"\"\n...\n</code></pre>"},{"location":"api-reference/hml.datasets/#hml.datasets.Dataset.samples","title":"samples  <code>property</code>","text":"<pre><code>samples: np.ndarray\n</code></pre> <p>The samples (data points) of the dataset.</p>"},{"location":"api-reference/hml.datasets/#hml.datasets.Dataset.targets","title":"targets  <code>property</code>","text":"<pre><code>targets: np.ndarray\n</code></pre> <p>The targets (integer labels) of the dataset.</p>"},{"location":"api-reference/hml.datasets/#hml.datasets.Dataset.description","title":"description  <code>property</code>","text":"<pre><code>description: str\n</code></pre> <p>The description of the dataset.</p>"},{"location":"api-reference/hml.datasets/#hml.datasets.Dataset.save","title":"save","text":"<pre><code>save(filepath, overwrite)\n</code></pre> <p>Save the dataset to a .npz file.</p> <p>It is required to save <code>_type</code> to distinguish between different datasets and load them correctly via <code>load_dataset</code> method.</p> Source code in <code>hml/datasets.py</code> <pre><code>def save(self, filepath: PathLike, overwrite: bool) -&gt; None:\n\"\"\"Save the dataset to a .npz file.\n    It is required to save `_type` to distinguish between different datasets\n    and load them correctly via `load_dataset` method.\n    \"\"\"\n...\n</code></pre>"},{"location":"api-reference/hml.datasets/#hml.datasets.Dataset.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(filepath)\n</code></pre> <p>Load the dataset from a .npz file.</p> Source code in <code>hml/datasets.py</code> <pre><code>@classmethod\ndef load(cls, filepath: PathLike) -&gt; Dataset:\n\"\"\"Load the dataset from a .npz file.\"\"\"\n...\n</code></pre>"},{"location":"api-reference/hml.datasets/#hml.datasets.TabularDataset","title":"TabularDataset","text":"<p>A tabular dataset.</p> <p>This is a class for tabular datasets. Samples are from 1D representation to build this 2D representation.</p> PARAMETER  DESCRIPTION <code>samples</code> <p>The samples (data points) of the dataset.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>targets</code> <p>The targets (integer labels) of the dataset.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>feature_names</code> <p>The names of the features.</p> <p> TYPE: <code>list[str]</code> </p> <code>target_names</code> <p>The names of the targets.</p> <p> TYPE: <code>list[str]</code> </p> <code>description</code> <p>The description of the dataset.</p> <p> TYPE: <code>str</code> </p> Source code in <code>hml/datasets.py</code> <pre><code>class TabularDataset:\n\"\"\"A tabular dataset.\n    This is a class for tabular datasets. Samples are from 1D representation to\n    build this 2D representation.\n    Parameters\n    ----------\n    samples : np.ndarray\n        The samples (data points) of the dataset.\n    targets : np.ndarray\n        The targets (integer labels) of the dataset.\n    feature_names : list[str]\n        The names of the features.\n    target_names : list[str]\n        The names of the targets.\n    description : str\n        The description of the dataset.\n    \"\"\"\ndef __init__(\nself,\nsamples: np.ndarray,\ntargets: np.ndarray,\nfeature_names: list[str],\ntarget_names: list[str],\ndescription: str,\n) -&gt; None:\nself._samples = samples\nself._targets = targets\nself._feature_names = feature_names\nself._target_names = target_names\nself._description = description\n@property\ndef samples(self) -&gt; np.ndarray:\nreturn self._samples\n@property\ndef targets(self) -&gt; np.ndarray:\nreturn self._targets\n@property\ndef feature_names(self) -&gt; list[str]:\nreturn self._feature_names\n@property\ndef target_names(self) -&gt; list[str]:\nreturn self._target_names\n@property\ndef description(self) -&gt; str:\nreturn self._description\ndef save(self, filepath: PathLike, overwrite: bool = True) -&gt; None:\nfilepath = Path(filepath)\nif filepath.exists():\nif overwrite:\nfilepath.unlink()\nelse:\nraise FileExistsError(f\"File {filepath} already exists\")\nnp.savez(\nfilepath,\nsamples=self.samples,\ntargets=self.targets,\nfeature_names=self.feature_names,\ntarget_names=self.target_names,\ndescription=self.description,\n_type=\"tabular\",\n)\n@classmethod\ndef load(cls, filepath: PathLike) -&gt; TabularDataset:\nfilepath = Path(filepath)\nif not filepath.exists():\nraise FileNotFoundError(f\"File {filepath} does not exist\")\ndata = np.load(filepath)\nreturn cls(\nsamples=data[\"samples\"],\ntargets=data[\"targets\"],\nfeature_names=data[\"feature_names\"],\ntarget_names=data[\"target_names\"],\ndescription=data[\"description\"].item(),\n)\n</code></pre>"},{"location":"api-reference/hml.datasets/#hml.datasets.load_dataset","title":"load_dataset","text":"<pre><code>load_dataset(filepath)\n</code></pre> <p>Load a dataset from a .npz file.</p> Source code in <code>hml/datasets.py</code> <pre><code>def load_dataset(filepath: PathLike) -&gt; Dataset:\n\"\"\"Load a dataset from a .npz file.\"\"\"\nfilepath = Path(filepath)\nif not filepath.exists():\nraise FileNotFoundError(f\"File {filepath} does not exist\")\ndata = np.load(filepath)\nif (_type := data.get(\"_type\").item()) is None:\nraise ValueError(\nf\"No `_type` key in {filepath}. Cannot load dataset anonymously, \"\nf\"try to determine the type of dataset and load it directly from \"\nf\"the corresponding class.\"\n)\nif _type not in DATASET_CLASSES:\nraise ValueError(\nf\"Unknown dataset type {_type}. Available types: \"\nf\"{', '.join(DATASET_CLASSES.keys())}\"\n)\nreturn DATASET_CLASSES[_type].load(filepath)\n</code></pre>"},{"location":"api-reference/hml.generators/","title":"hml.generators","text":""},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5","title":"Madgraph5","text":"<p>Wrapper class for Madgraph5.</p> <p>It uses commands from MadEvent (<code>launch -i</code> in Madgraph5 CLI) to launch runs sequentially. It also provides a summary of the runs similar to the website provided by Madgraph5.</p> PARAMETER  DESCRIPTION <code>processes</code> <p>List of processes to generate.</p> <p> TYPE: <code>list[str]</code> </p> <code>executable</code> <p>Path to the Madgraph5 executable, by default \"mg5_aMC\".</p> <p> TYPE: <code>PathLike</code> DEFAULT: <code>'mg5_aMC'</code> </p> <code>model</code> <p>Path to the model or the name of the model, by default \"sm\".</p> <p> TYPE: <code>PathLike</code> DEFAULT: <code>'sm'</code> </p> <code>definitions</code> <p>Dictionary of definitions to pass to Madgraph5, by default {}.</p> <p> TYPE: <code>dict[str, Any]</code> DEFAULT: <code>{}</code> </p> <code>output</code> <p>Path to the output directory, by default \"madevent\".</p> <p> TYPE: <code>PathLike</code> DEFAULT: <code>'madevent'</code> </p> <code>log_dir</code> <p>Path to the log directory relative to the output, by default \"Logs\".</p> <p> TYPE: <code>PathLike</code> DEFAULT: <code>'Logs'</code> </p> <p>The relation between the parameters and the Madgraph5 commands is as follows:</p> Parameters Commands or options model import model command definitions define command processes generate &amp; add process commands output output command Source code in <code>hml/generators.py</code> <pre><code>class Madgraph5:\n\"\"\"Wrapper class for Madgraph5.\n    It uses commands from MadEvent (`launch -i` in Madgraph5 CLI) to launch runs\n    sequentially. It also provides a summary of the runs similar to the website\n    provided by Madgraph5.\n    Parameters\n    ----------\n    processes : list[str]\n        List of processes to generate.\n    executable : PathLike, optional\n        Path to the Madgraph5 executable, by default \"mg5_aMC\".\n    model : PathLike, optional\n        Path to the model or the name of the model, by default \"sm\".\n    definitions : dict[str, Any], optional\n        Dictionary of definitions to pass to Madgraph5, by default {}.\n    output : PathLike, optional\n        Path to the output directory, by default \"madevent\".\n    log_dir : PathLike, optional\n        Path to the log directory relative to the output, by default \"Logs\".\n    The relation between the parameters and the Madgraph5 commands is as follows:\n    | Parameters  | Commands or options              |\n    | ----------- | -------------------------------- |\n    | model       | import model command             |\n    | definitions | define command                   |\n    | processes   | generate &amp; add process commands  |\n    | output      | output command                   |\n    \"\"\"\ndef __init__(\nself,\nprocesses: list[str],\nexecutable: PathLike = \"mg5_aMC\",\nmodel: PathLike = \"sm\",\ndefinitions: dict[str, Any] = {},\noutput: PathLike = \"madevent\",\nlog_dir: PathLike = \"Logs\",\n) -&gt; None:\n# Set properties ----------------------------------------------------- #\nself.executable = executable\nself.model = model\nself.definitions = definitions\nself.processes = processes\nself.output = Path(output)\nself.commands = {\n\"pre\": [\n*[f\"import model {self.model}\"],\n*[f\"define {k} = {v}\" for k, v in self.definitions.items()],\n*[f\"generate {self.processes[0]}\"],\n*[f\"add process {p}\" for p in self.processes[1:]],\n*[f\"output {self.output}\"],\n],\n}\n# Create output directory -------------------------------------------- #\ncommand_file = self._cmds_to_file(self.commands[\"pre\"])\nif not self.output.exists():\n# Run Madgraph5\nprocess = subprocess.Popen(\nf\"{self.executable} {command_file}\",\nshell=True,\nstdin=subprocess.PIPE,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\n# Remove py.py file after initialization\nif process.poll() is not None:\nif Path(\"py.py\").exists():\nPath(\"py.py\").unlink()\n# Check if there's an error message in stderr\n# Note:\n# when importing a model like heft that needs to be downloaded,\n# the success message is wrongly printed in stderr. This is why we\n# check for the word \"error\" in stderr.\n_, stderr = process.communicate()\nif \"error\" in stderr.decode().lower():\n# if stderr:\nraise RuntimeError(stderr.decode())\n# After output directory is created, set log directory\nself.log_dir = log_dir\ndef launch(\nself,\nshower: ShowerOption = \"off\",\ndetector: DetectorOption = \"off\",\nsettings: dict[str, Any] = {},\ncards: list[PathLike] = [],\nmulti_run: int = 1,\nverbose: int = 1,\n):\n\"\"\"The launch command in Madgraph5 CLI.\n        Parameters\n        ----------\n        shower : ShowerOption, optional\n            Shower tool to use, currently supports \"off\" and \"pythia8\", by\n            default \"off\".\n        detector : DetectorOption, optional\n            Detector tool to use, currently supports \"off\" and \"delphes\", by\n            default \"off\".\n        settings : dict[str, Any], optional\n            Dictionary of settings to pass to Madgraph5, by default {}.\n        cards : list[PathLike], optional\n            List of cards to pass to Madgraph5, by default [].\n        multi_run : int, optional\n            Number of runs to launch, by default 1.\n        verbose : int, optional\n            Verbosity level, 0 for quiet, 1 for simple, by default 1.\n        The relation between the parameters and the Madgraph5 commands is as\n        follows:\n        | shower      | shower option                                     |\n        | detector    | detector option                                   |\n        | settings    | set command                                       |\n        | cards       | card paths directly passed when configuring cards |\n        \"\"\"\nif shower not in [\"off\", \"pythia8\"]:\nraise ValueError(f\"Unknown shower tool {shower}\")\nif detector not in [\"off\", \"delphes\"]:\nraise ValueError(f\"Unknown detector tool {detector}\")\nself.shower = shower\nself.detector = detector\nself.settings = settings\nself.cards = [Path(card).resolve() for card in cards]\nself.multi_run = multi_run\n# -------------------------------------------------------------------- #\ncommands = [\n*[f\"launch -i {self.output}\"],\n*[f\"multi_run {self.multi_run}\"],\n*[f\"shower={self.shower}\"],\n*[f\"detector={self.detector}\"],\n*[f\"set {k} {v}\" for k, v in self.settings.items()],\n*[f\"{card}\" for card in self.cards],\n]\ncommand_file = self._cmds_to_file(commands)\n# -------------------------------------------------------------------- #\nn_runs = len(list((self.output / \"Events\").glob(\"*_banner.txt\")))\nrun_name = f\"run_{n_runs+1:02d}\"\nlog_file = self.log_dir / f\"{run_name}.log\"\nself.commands[run_name] = commands\n# -------------------------------------------------------------------- #\nwith open(log_file, \"w\") as f:\n_, child = pty.openpty()\nprocess = subprocess.Popen(\nf\"{self.executable} {command_file}\",\nshell=True,\nstdin=child,\nstdout=f,\nstderr=child,\n)\n# -------------------------------------------------------------------- #\nself._check_status(log_file, process, verbose)\nos.close(child)\n# -------------------------------------------------------------------- #\n_, stderr = process.communicate()\nif stderr:\nraise RuntimeError(stderr.decode())  # pragma: no cover\n# -------------------------------------------------------------------- #\nreturn Madgraph5MultiRun.from_name(run_name, self.output)\n@property\ndef executable(self) -&gt; Path:\nreturn self._executable\n@executable.setter\ndef executable(self, value: PathLike):\nif (_executable := shutil.which(value)) is None:\nraise EnvironmentError(f\"{value} is not a valid executable\")\nself._executable = Path(_executable).resolve()\n@property\ndef model(self) -&gt; PathLike:\nreturn self._model\n@model.setter\ndef model(self, value: PathLike):\nself._model = value\n@property\ndef definitions(self) -&gt; dict[str, Any]:\nreturn self._definitions\n@definitions.setter\ndef definitions(self, value: dict[str, Any]):\nself._definitions = value\n@property\ndef processes(self) -&gt; list[str]:\nreturn self._processes\n@processes.setter\ndef processes(self, value: list[str]):\nself._processes = value\n@property\ndef output(self) -&gt; Path:\nreturn self._output\n@output.setter\ndef output(self, value: PathLike):\n_output = Path(value).resolve()\nself._output = _output\n@property\ndef log_dir(self) -&gt; Path:\nreturn self._log_dir\n@log_dir.setter\ndef log_dir(self, value: PathLike):\n_log_dir = self.output / value\n_log_dir.mkdir(exist_ok=True)\nself._log_dir = _log_dir\n@property\ndef runs(self) -&gt; list[Madgraph5MultiRun]:\n\"\"\"List of runs in the output directory.\"\"\"\nrun_paths = []\nfor i in self.output.glob(\"Events/run_*\"):\nif i.is_dir() and i.name.count(\"_\") == 1:\nrun_paths.append(i)\n# Sort the runs by their number\nrun_paths = sorted(run_paths, key=lambda x: int(x.name.split(\"_\")[-1]))\nruns = [Madgraph5MultiRun.from_name(i.name, self.output) for i in run_paths]\nreturn runs\n@classmethod\ndef from_output(cls, output: PathLike, executable: PathLike = \"mg5_aMC\"):\n\"\"\"Create a Madgraph5 instance from an existing output directory.\"\"\"\noutput = Path(output).resolve()\nif not output.exists():\nraise FileNotFoundError(f\"{output} does not exist.\")\nproc_card = output / \"Cards/proc_card_mg5.dat\"\nmodel = \"sm\"\ndefinitions = {}\nprocesses = []\nwith proc_card.open() as f:\nfor line in f.readlines():\nif line.startswith(\"import model\"):\nmodel = line.split()[2]\nif line.startswith(\"define\"):\nkey, value = line.replace(\"define \", \"\").split(\"=\")\ndefinitions[key.strip()] = value.strip()\nif line.startswith(\"generate\"):\nprocesses.append(line.replace(\"generate \", \"\").strip())\nif line.startswith(\"add process\"):\nprocesses.append(line.replace(\"add process \", \"\").strip())\nreturn cls(\nprocesses=processes,\nexecutable=executable,\nmodel=model,\ndefinitions=definitions,\noutput=output,\n)\ndef summary(self):\n\"\"\"Print a summary of the runs in the output directory.\"\"\"\nconsole = Console()\ntable = Table(\ntitle=\"\\n\".join(self.processes),\ncaption=f\"Output: {self.output}\",\n)\ntable.add_column(\"#\", justify=\"right\")\ntable.add_column(\"Name\")\ntable.add_column(\"Tag\")\ntable.add_column(\"Cross section (pb)\", justify=\"center\")\ntable.add_column(\"N events\", justify=\"right\")\ntable.add_column(\"Seed\", justify=\"right\")\nfor i, multi_run in enumerate(self.runs):\ntable.add_row(\nf\"{i}\",\nf\"{multi_run.name}[{len(multi_run.runs)}]\",\nf\"{multi_run.tag}\",\nf\"{multi_run.cross_section:.3e}\",\nf\"{multi_run.n_events:,}\",\nf\"{multi_run.seed}\",\n)\nconsole.print(table)\ndef _cmds_to_file(self, cmds: list[str]) -&gt; str:\nwith tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as temp_file:\ntemp_file.write(\"\\n\".join(cmds))\ntemp_file_path = temp_file.name\nreturn temp_file_path\ndef _check_status(\nself,\nlog_file: Path,\nprocess: subprocess.Popen,\nverbose=1,\n) -&gt; None:\n# -------------------------------------------------------------------- #\nstatus_markers = {\n\"Running Survey\": \"Running Survey\",\n\"Running Pythia8\": \"Running Pythia8\",\n\"Running Delphes\": \"Running Delphes\",\n\"storing files\": \"Storing files\",\n}\ncurrent_run = 1\nlast_position = 0\nlast_known_status = -1  # This will help to avoid repeating the same status.\n# Determine the index of the \"storing files\" status, since it's the\n# repeating endpoint for each run\nstoring_files_idx = list(status_markers.keys()).index(\"storing files\")\n# -------------------------------------------------------------------- #\n# Monitor the process and the log file\nwhile True:\nif Path(\"py.py\").exists():\nPath(\"py.py\").unlink()\n# Check the log file for status updates\nwith open(log_file, \"r\") as f:\nf.seek(last_position)\ncontent = f.read()\nlast_position = f.tell()\nfor idx, (marker, status) in enumerate(status_markers.items()):\nif marker in content and idx &gt; last_known_status:\nif verbose:\nprint(status)\nif idx == storing_files_idx:\ncurrent_run += 1\nif current_run &gt; self.multi_run:\nlast_known_status = idx\nelse:\nlast_known_status = -1\nif verbose:\nprint()\nelse:\nlast_known_status = idx\n# Check if process is still running\nif process.poll() is not None:  # Process has finished\nif verbose:\nprint(\"Done\")\nbreak\n</code></pre>"},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5.runs","title":"runs  <code>property</code>","text":"<pre><code>runs: list[Madgraph5MultiRun]\n</code></pre> <p>List of runs in the output directory.</p>"},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5.launch","title":"launch","text":"<pre><code>launch(\nshower=\"off\",\ndetector=\"off\",\nsettings={},\ncards=[],\nmulti_run=1,\nverbose=1,\n)\n</code></pre> <p>The launch command in Madgraph5 CLI.</p> PARAMETER  DESCRIPTION <code>shower</code> <p>Shower tool to use, currently supports \"off\" and \"pythia8\", by default \"off\".</p> <p> TYPE: <code>ShowerOption</code> DEFAULT: <code>'off'</code> </p> <code>detector</code> <p>Detector tool to use, currently supports \"off\" and \"delphes\", by default \"off\".</p> <p> TYPE: <code>DetectorOption</code> DEFAULT: <code>'off'</code> </p> <code>settings</code> <p>Dictionary of settings to pass to Madgraph5, by default {}.</p> <p> TYPE: <code>dict[str, Any]</code> DEFAULT: <code>{}</code> </p> <code>cards</code> <p>List of cards to pass to Madgraph5, by default [].</p> <p> TYPE: <code>list[PathLike]</code> DEFAULT: <code>[]</code> </p> <code>multi_run</code> <p>Number of runs to launch, by default 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>verbose</code> <p>Verbosity level, 0 for quiet, 1 for simple, by default 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <p>The relation between the parameters and the Madgraph5 commands is as follows:</p> <p>| shower      | shower option                                     | | detector    | detector option                                   | | settings    | set command                                       | | cards       | card paths directly passed when configuring cards |</p> Source code in <code>hml/generators.py</code> <pre><code>def launch(\nself,\nshower: ShowerOption = \"off\",\ndetector: DetectorOption = \"off\",\nsettings: dict[str, Any] = {},\ncards: list[PathLike] = [],\nmulti_run: int = 1,\nverbose: int = 1,\n):\n\"\"\"The launch command in Madgraph5 CLI.\n    Parameters\n    ----------\n    shower : ShowerOption, optional\n        Shower tool to use, currently supports \"off\" and \"pythia8\", by\n        default \"off\".\n    detector : DetectorOption, optional\n        Detector tool to use, currently supports \"off\" and \"delphes\", by\n        default \"off\".\n    settings : dict[str, Any], optional\n        Dictionary of settings to pass to Madgraph5, by default {}.\n    cards : list[PathLike], optional\n        List of cards to pass to Madgraph5, by default [].\n    multi_run : int, optional\n        Number of runs to launch, by default 1.\n    verbose : int, optional\n        Verbosity level, 0 for quiet, 1 for simple, by default 1.\n    The relation between the parameters and the Madgraph5 commands is as\n    follows:\n    | shower      | shower option                                     |\n    | detector    | detector option                                   |\n    | settings    | set command                                       |\n    | cards       | card paths directly passed when configuring cards |\n    \"\"\"\nif shower not in [\"off\", \"pythia8\"]:\nraise ValueError(f\"Unknown shower tool {shower}\")\nif detector not in [\"off\", \"delphes\"]:\nraise ValueError(f\"Unknown detector tool {detector}\")\nself.shower = shower\nself.detector = detector\nself.settings = settings\nself.cards = [Path(card).resolve() for card in cards]\nself.multi_run = multi_run\n# -------------------------------------------------------------------- #\ncommands = [\n*[f\"launch -i {self.output}\"],\n*[f\"multi_run {self.multi_run}\"],\n*[f\"shower={self.shower}\"],\n*[f\"detector={self.detector}\"],\n*[f\"set {k} {v}\" for k, v in self.settings.items()],\n*[f\"{card}\" for card in self.cards],\n]\ncommand_file = self._cmds_to_file(commands)\n# -------------------------------------------------------------------- #\nn_runs = len(list((self.output / \"Events\").glob(\"*_banner.txt\")))\nrun_name = f\"run_{n_runs+1:02d}\"\nlog_file = self.log_dir / f\"{run_name}.log\"\nself.commands[run_name] = commands\n# -------------------------------------------------------------------- #\nwith open(log_file, \"w\") as f:\n_, child = pty.openpty()\nprocess = subprocess.Popen(\nf\"{self.executable} {command_file}\",\nshell=True,\nstdin=child,\nstdout=f,\nstderr=child,\n)\n# -------------------------------------------------------------------- #\nself._check_status(log_file, process, verbose)\nos.close(child)\n# -------------------------------------------------------------------- #\n_, stderr = process.communicate()\nif stderr:\nraise RuntimeError(stderr.decode())  # pragma: no cover\n# -------------------------------------------------------------------- #\nreturn Madgraph5MultiRun.from_name(run_name, self.output)\n</code></pre>"},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5.from_output","title":"from_output  <code>classmethod</code>","text":"<pre><code>from_output(output, executable='mg5_aMC')\n</code></pre> <p>Create a Madgraph5 instance from an existing output directory.</p> Source code in <code>hml/generators.py</code> <pre><code>@classmethod\ndef from_output(cls, output: PathLike, executable: PathLike = \"mg5_aMC\"):\n\"\"\"Create a Madgraph5 instance from an existing output directory.\"\"\"\noutput = Path(output).resolve()\nif not output.exists():\nraise FileNotFoundError(f\"{output} does not exist.\")\nproc_card = output / \"Cards/proc_card_mg5.dat\"\nmodel = \"sm\"\ndefinitions = {}\nprocesses = []\nwith proc_card.open() as f:\nfor line in f.readlines():\nif line.startswith(\"import model\"):\nmodel = line.split()[2]\nif line.startswith(\"define\"):\nkey, value = line.replace(\"define \", \"\").split(\"=\")\ndefinitions[key.strip()] = value.strip()\nif line.startswith(\"generate\"):\nprocesses.append(line.replace(\"generate \", \"\").strip())\nif line.startswith(\"add process\"):\nprocesses.append(line.replace(\"add process \", \"\").strip())\nreturn cls(\nprocesses=processes,\nexecutable=executable,\nmodel=model,\ndefinitions=definitions,\noutput=output,\n)\n</code></pre>"},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5.summary","title":"summary","text":"<pre><code>summary()\n</code></pre> <p>Print a summary of the runs in the output directory.</p> Source code in <code>hml/generators.py</code> <pre><code>def summary(self):\n\"\"\"Print a summary of the runs in the output directory.\"\"\"\nconsole = Console()\ntable = Table(\ntitle=\"\\n\".join(self.processes),\ncaption=f\"Output: {self.output}\",\n)\ntable.add_column(\"#\", justify=\"right\")\ntable.add_column(\"Name\")\ntable.add_column(\"Tag\")\ntable.add_column(\"Cross section (pb)\", justify=\"center\")\ntable.add_column(\"N events\", justify=\"right\")\ntable.add_column(\"Seed\", justify=\"right\")\nfor i, multi_run in enumerate(self.runs):\ntable.add_row(\nf\"{i}\",\nf\"{multi_run.name}[{len(multi_run.runs)}]\",\nf\"{multi_run.tag}\",\nf\"{multi_run.cross_section:.3e}\",\nf\"{multi_run.n_events:,}\",\nf\"{multi_run.seed}\",\n)\nconsole.print(table)\n</code></pre>"},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5Run","title":"Madgraph5Run  <code>dataclass</code>","text":"<p>A single run of Madgraph5.</p> <p>Single run includes complete information about the run. It is usually launced by the <code>launch</code> command in Madgraph5 CLI or the <code>generate_events</code> command in MadEvent CLI.</p> PARAMETER  DESCRIPTION <code>name</code> <p>Name of the run, e.g. \"run_01\", \"run_02_0\".</p> <p> TYPE: <code>str</code> </p> <code>tag</code> <p>Tag of the run, by default \"\" (not the same as \"tag_1\" in Madgraph5).</p> <p> TYPE: <code>str</code> </p> <code>directory</code> <p>Path to the directory of the run.</p> <p> TYPE: <code>PathLike</code> </p> <code>seed</code> <p>Random seed of the run.</p> <p> TYPE: <code>int</code> </p> <code>n_events</code> <p>Number of events in the run parsed from the banner file and the root files. The latter shall prevail.</p> <p> TYPE: <code>int</code> </p> <code>cross_section</code> <p>Cross section of the run.</p> <p> TYPE: <code>float</code> </p> <code>collider</code> <p>Collider configurations of the run.</p> <p> TYPE: <code>str</code> </p> <code>events</code> <p>TChain of the root files in the run.</p> <p> TYPE: <code>ROOT.TChain</code> </p> Source code in <code>hml/generators.py</code> <pre><code>@dataclass\nclass Madgraph5Run:\n\"\"\"A single run of Madgraph5.\n    Single run includes complete information about the run. It is usually\n    launced by the `launch` command in Madgraph5 CLI or the `generate_events`\n    command in MadEvent CLI.\n    Parameters\n    ----------\n    name : str\n        Name of the run, e.g. \"run_01\", \"run_02_0\".\n    tag : str\n        Tag of the run, by default \"\" (not the same as \"tag_1\" in Madgraph5).\n    directory : PathLike\n        Path to the directory of the run.\n    seed : int\n        Random seed of the run.\n    n_events : int\n        Number of events in the run parsed from the banner file and the root\n        files. The latter shall prevail.\n    cross_section : float\n        Cross section of the run.\n    collider : str\n        Collider configurations of the run.\n    events : ROOT.TChain\n        TChain of the root files in the run.\n    \"\"\"\nname: str\ntag: str\ndirectory: Path\nseed: int\nn_events: int\ncross_section: float\ncollider: str\nevents: ROOT.TChain  # type: ignore\n@classmethod\ndef from_directory(cls, directory: PathLike):\ndirectory = Path(directory)\nif not directory.exists():\nraise FileNotFoundError(f\"{directory} does not exist.\")\nname = directory.name\nif len(banners := list(directory.glob(\"*_banner.txt\"))) == 0:\nraise FileNotFoundError(f\"No banner found in {directory}\")\nelse:\nbanner = banners[0]\nlpps = {\"1\": \"p\", \"2\": \"e\"}\ntag = \"\"\nn_events = 0\nseed = 0\nlpp1, lpp2 = \"\", \"\"\nebeam1, ebeam2 = 0.0, 0.0\ncross_section = 0.0\nevents = ROOT.TChain(\"Delphes\")  # type: ignore\nfor root_file in directory.glob(\"*.root\"):\nevents.Add(str(root_file))\nwith banner.open() as f:\nfor line in f.readlines():\nif \"run_tag\" in line:\ntag = line.split(\"=\")[0].strip()\nif \"nevents\" in line:\nn_events = int(line.split(\"=\")[0].strip())\nif n_events != events.GetEntries():\nn_events = events.GetEntries()  # pragma: no cover\nif \"iseed\" in line:\nseed = int(line.split(\"=\")[0].strip())\nif \"lpp1\" in line:\nlpp1 = lpps.get(line.split(\"=\")[0].strip(), \"\")\nif \"lpp2\" in line:\nlpp2 = lpps.get(line.split(\"=\")[0].strip(), \"\")\nif \"ebeam1\" in line:\nebeam1 = float(line.split(\"=\")[0].strip())\nif \"ebeam2\" in line:\nebeam2 = float(line.split(\"=\")[0].strip())\nif \"Integrated weight (pb)\" in line:\ncross_section = float(line.split()[-1].strip())\ncollider = f\"{lpp1}{lpp2}: {ebeam1}x{ebeam2}\"\nreturn cls(\nname, tag, directory, seed, n_events, cross_section, collider, events\n)\n</code></pre>"},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5MultiRun","title":"Madgraph5MultiRun  <code>dataclass</code>","text":"<p>A run launched by multi_run of MadEvent.</p> <p>A multi-run is a collection of runs launched by the <code>multi_run</code> command in MadEvent CLI that is launched by the <code>launch -i</code> command in Madgraph5 CLI. It usually contains one \"run_xx\" directory, one \"run_xx_banner.txt\" file, and several \"run_xx_y\" single runs.</p> PARAMETER  DESCRIPTION <code>name</code> <p>Name of the run, e.g. \"run_01\".</p> <p> TYPE: <code>str</code> </p> <code>tag</code> <p>Tag of the run, by default \"\" (not the same as \"tag_1\" in Madgraph5).</p> <p> TYPE: <code>str</code> </p> <code>seed</code> <p>Random seed of the run.</p> <p> TYPE: <code>int</code> </p> <code>n_events</code> <p>Number of events in the run parsed from the banner file and the root files. The latter shall prevail.</p> <p> TYPE: <code>int</code> </p> <code>cross_section</code> <p>Cross section of the run.</p> <p> TYPE: <code>float</code> </p> <code>collider</code> <p>Collider configurations of the run.</p> <p> TYPE: <code>str</code> </p> <code>events</code> <p>TChain of the root files in the run.</p> <p> TYPE: <code>ROOT.TChain</code> </p> <code>runs</code> <p>The single runs in the multi-run.</p> <p> TYPE: <code>list[Madgraph5Run]</code> </p> Source code in <code>hml/generators.py</code> <pre><code>@dataclass\nclass Madgraph5MultiRun:\n\"\"\"A run launched by multi_run of MadEvent.\n    A multi-run is a collection of runs launched by the `multi_run` command in\n    MadEvent CLI that is launched by the `launch -i` command in Madgraph5 CLI.\n    It usually contains one \"run_xx\" directory, one \"run_xx_banner.txt\" file,\n    and several \"run_xx_y\" single runs.\n    Parameters\n    ----------\n    name : str\n        Name of the run, e.g. \"run_01\".\n    tag : str\n        Tag of the run, by default \"\" (not the same as \"tag_1\" in Madgraph5).\n    seed : int\n        Random seed of the run.\n    n_events : int\n        Number of events in the run parsed from the banner file and the root\n        files. The latter shall prevail.\n    cross_section : float\n        Cross section of the run.\n    collider : str\n        Collider configurations of the run.\n    events : ROOT.TChain\n        TChain of the root files in the run.\n    runs : list[Madgraph5Run]\n        The single runs in the multi-run.\n    \"\"\"\nname: str\ntag: str\nseed: int\nn_events: int\ncross_section: float\ncollider: str\nevents: ROOT.TChain  # type: ignore\nruns: list[Madgraph5Run]\n@classmethod\ndef from_name(cls, name: str, output: PathLike = \"madevent\"):\n\"\"\"Create a multi-run from the name of the run and the output directory.\"\"\"\noutput = Path(output)\nif not output.exists():\nraise FileNotFoundError(f\"{output} does not exist.\")\nevents_dir = output / \"Events\"\nif len(banners := list(events_dir.glob(f\"{name}_banner.txt\"))) == 0:\nraise FileNotFoundError(f\"No run named {name} found in {output}\")\nelse:\nbanner = banners[0]\nruns = [i for i in events_dir.glob(f\"{name}_*\") if i.is_dir()]\nruns = sorted(runs, key=lambda x: int(x.name.split(\"_\")[-1]))\nruns = [Madgraph5Run.from_directory(run) for run in runs]\nlpps = {\"1\": \"p\", \"2\": \"e\"}\ntag = \"\"\nn_events = 0\nseed = 0\nlpp1, lpp2 = \"\", \"\"\nebeam1, ebeam2 = 0.0, 0.0\ncross_section = 0.0\nevents = ROOT.TChain(\"Delphes\")  # type: ignore\nfor root_file in events_dir.glob(f\"{name}_*/*.root\"):\nevents.Add(str(root_file))\nwith banner.open() as f:\nfor line in f.readlines():\nif \"run_tag\" in line:\ntag = line.split(\"=\")[0].strip()\nif \"nevents\" in line:\nn_events = int(line.split(\"=\")[0].strip())\nif n_events != events.GetEntries() and events.GetEntries() != 0:\nn_events = events.GetEntries()\nif \"iseed\" in line:\nseed = int(line.split(\"=\")[0].strip())\nif \"lpp1\" in line:\nlpp1 = lpps.get(line.split(\"=\")[0].strip(), \"\")\nif \"lpp2\" in line:\nlpp2 = lpps.get(line.split(\"=\")[0].strip(), \"\")\nif \"ebeam1\" in line:\nebeam1 = float(line.split(\"=\")[0].strip())\nif \"ebeam2\" in line:\nebeam2 = float(line.split(\"=\")[0].strip())\nif \"Integrated weight (pb)\" in line:\ncross_section = float(line.split()[-1].strip())\ncollider = f\"{lpp1}{lpp2}: {ebeam1}x{ebeam2}\"\nreturn cls(\nname,\ntag,\nseed,\nn_events,\ncross_section,\ncollider,\nevents,\nruns,\n)\n</code></pre>"},{"location":"api-reference/hml.generators/#hml.generators.Madgraph5MultiRun.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name, output='madevent')\n</code></pre> <p>Create a multi-run from the name of the run and the output directory.</p> Source code in <code>hml/generators.py</code> <pre><code>@classmethod\ndef from_name(cls, name: str, output: PathLike = \"madevent\"):\n\"\"\"Create a multi-run from the name of the run and the output directory.\"\"\"\noutput = Path(output)\nif not output.exists():\nraise FileNotFoundError(f\"{output} does not exist.\")\nevents_dir = output / \"Events\"\nif len(banners := list(events_dir.glob(f\"{name}_banner.txt\"))) == 0:\nraise FileNotFoundError(f\"No run named {name} found in {output}\")\nelse:\nbanner = banners[0]\nruns = [i for i in events_dir.glob(f\"{name}_*\") if i.is_dir()]\nruns = sorted(runs, key=lambda x: int(x.name.split(\"_\")[-1]))\nruns = [Madgraph5Run.from_directory(run) for run in runs]\nlpps = {\"1\": \"p\", \"2\": \"e\"}\ntag = \"\"\nn_events = 0\nseed = 0\nlpp1, lpp2 = \"\", \"\"\nebeam1, ebeam2 = 0.0, 0.0\ncross_section = 0.0\nevents = ROOT.TChain(\"Delphes\")  # type: ignore\nfor root_file in events_dir.glob(f\"{name}_*/*.root\"):\nevents.Add(str(root_file))\nwith banner.open() as f:\nfor line in f.readlines():\nif \"run_tag\" in line:\ntag = line.split(\"=\")[0].strip()\nif \"nevents\" in line:\nn_events = int(line.split(\"=\")[0].strip())\nif n_events != events.GetEntries() and events.GetEntries() != 0:\nn_events = events.GetEntries()\nif \"iseed\" in line:\nseed = int(line.split(\"=\")[0].strip())\nif \"lpp1\" in line:\nlpp1 = lpps.get(line.split(\"=\")[0].strip(), \"\")\nif \"lpp2\" in line:\nlpp2 = lpps.get(line.split(\"=\")[0].strip(), \"\")\nif \"ebeam1\" in line:\nebeam1 = float(line.split(\"=\")[0].strip())\nif \"ebeam2\" in line:\nebeam2 = float(line.split(\"=\")[0].strip())\nif \"Integrated weight (pb)\" in line:\ncross_section = float(line.split()[-1].strip())\ncollider = f\"{lpp1}{lpp2}: {ebeam1}x{ebeam2}\"\nreturn cls(\nname,\ntag,\nseed,\nn_events,\ncross_section,\ncollider,\nevents,\nruns,\n)\n</code></pre>"},{"location":"api-reference/hml.metrics/","title":"hml.metrics","text":""},{"location":"api-reference/hml.observables/","title":"hml.observables","text":""},{"location":"api-reference/hml.observables/#hml.observables.Observable","title":"Observable","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for observables.</p> <p>Implement the <code>get_value</code> method to define a new observable.</p> Source code in <code>hml/observables.py</code> <pre><code>class Observable(ABC):\n\"\"\"Base class for observables.\n    Implement the `get_value` method to define a new observable.\n    \"\"\"\nall_observables = {}\ndef __init__(\nself,\nshortcut: str | None = None,\nobject_pairs: list[tuple[str, int | None]] | None = None,\n) -&gt; None:\nself.seprate_branch_name_and_index = \"_\"\nself.separate_objects = \"-\"\nif shortcut:\nself.shortcut = shortcut\nself.object_pairs = self.parse_shortcut(shortcut)\nelif object_pairs:\nself.shortcut = self.build_shortcut(object_pairs)\nself.object_pairs = object_pairs\nelse:\nself.shortcut = None\nself.object_pairs = None\nself._value = None\n@property\ndef name(self) -&gt; str:\n\"\"\"The name of the observable.\n        The name is composed of the shortcut and the class name, e.g. `Jet_0.Pt`.\n        \"\"\"\nif self.shortcut:\nreturn f\"{self.shortcut}.{self.__class__.__name__}\"\nelse:\nreturn self.__class__.__name__\n@property\ndef value(self) -&gt; Any:\n\"\"\"The value of the observable.\"\"\"\nreturn self._value\ndef to_numpy(self) -&gt; np.ndarray:\n\"\"\"Convert the value to a numpy array.\"\"\"\nreturn np.array(self.value, dtype=np.float32)\ndef __repr__(self) -&gt; str:\n\"\"\"The representation of the observable.\"\"\"\nreturn f\"{self.name}: {self.value}\"\ndef read_event(self, event: TTree) -&gt; Observable:\n\"\"\"Read an event and fetch the needed physics objects.\n        It creates three attributes: event, objects and _value. The _value is\n        calculated by calling the `get_value` method.\n        \"\"\"\nself.event = event\nself.objects = []\nself._value = None\nif self.object_pairs:\nfor branch_name, index in self.object_pairs:\nif branch_name in event.GetListOfBranches():\nbranch = getattr(event, branch_name)\nif index is None:\nself.objects.append([i for i in branch])\nelif index &lt; branch.GetEntries():\nself.objects.append(branch[index])\nself._value = self.get_value()\nreturn self\n@abstractmethod\ndef get_value(self) -&gt; Any:\n\"\"\"Calculate the value of the observable.\n        Implement this method to define a new observable. Here're common cases:\n        1. Quick calculation: use `self.event` to get physics objects and write\n        the calculation directly.\n        2. Take the advantage of Observable: use `self.objects` to do the\n        calculation.\n        Return None if the observable is not correctly got.\n        \"\"\"\n...  # pragma: no cover\ndef parse_shortcut(self, shortcut: str) -&gt; list[tuple[str, int | None]]:\n\"\"\"Parse the shortcut to get the object pairs.\"\"\"\nobject_pairs = []\nobjects = shortcut.split(self.separate_objects)\nfor obj in objects:\nif \"_\" in obj:\nbranch_name, index = obj.split(self.seprate_branch_name_and_index)\nindex = int(index)\nelse:\nbranch_name, index = obj, None\nobject_pairs.append((branch_name, index))\nreturn object_pairs\ndef build_shortcut(self, object_pairs: list[tuple[str, int | None]]) -&gt; str:\n\"\"\"Build the shortcut from the object pairs.\"\"\"\nshortcuts = []\nfor branch_name, index in object_pairs:\nif index is not None:\nobj = f\"{branch_name}{self.seprate_branch_name_and_index}{index}\"\nelse:\nobj = branch_name\nshortcuts.append(obj)\nreturn self.separate_objects.join(shortcuts)\ndef __init_subclass__(cls, **kwargs) -&gt; None:\nsuper().__init_subclass__(**kwargs)\nObservable.all_observables[cls.__name__] = cls\n@classmethod\ndef add_alias(cls, *alias: str) -&gt; None:\n\"\"\"Add alias for the class name.\"\"\"\nfor i in alias:\nObservable.all_observables[i] = cls\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the observable.</p> <p>The name is composed of the shortcut and the class name, e.g. <code>Jet_0.Pt</code>.</p>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.value","title":"value  <code>property</code>","text":"<pre><code>value: Any\n</code></pre> <p>The value of the observable.</p>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy()\n</code></pre> <p>Convert the value to a numpy array.</p> Source code in <code>hml/observables.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n\"\"\"Convert the value to a numpy array.\"\"\"\nreturn np.array(self.value, dtype=np.float32)\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>The representation of the observable.</p> Source code in <code>hml/observables.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"The representation of the observable.\"\"\"\nreturn f\"{self.name}: {self.value}\"\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.read_event","title":"read_event","text":"<pre><code>read_event(event)\n</code></pre> <p>Read an event and fetch the needed physics objects.</p> <p>It creates three attributes: event, objects and _value. The _value is calculated by calling the <code>get_value</code> method.</p> Source code in <code>hml/observables.py</code> <pre><code>def read_event(self, event: TTree) -&gt; Observable:\n\"\"\"Read an event and fetch the needed physics objects.\n    It creates three attributes: event, objects and _value. The _value is\n    calculated by calling the `get_value` method.\n    \"\"\"\nself.event = event\nself.objects = []\nself._value = None\nif self.object_pairs:\nfor branch_name, index in self.object_pairs:\nif branch_name in event.GetListOfBranches():\nbranch = getattr(event, branch_name)\nif index is None:\nself.objects.append([i for i in branch])\nelif index &lt; branch.GetEntries():\nself.objects.append(branch[index])\nself._value = self.get_value()\nreturn self\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.get_value","title":"get_value  <code>abstractmethod</code>","text":"<pre><code>get_value()\n</code></pre> <p>Calculate the value of the observable.</p> <p>Implement this method to define a new observable. Here're common cases: 1. Quick calculation: use <code>self.event</code> to get physics objects and write the calculation directly. 2. Take the advantage of Observable: use <code>self.objects</code> to do the calculation.</p> <p>Return None if the observable is not correctly got.</p> Source code in <code>hml/observables.py</code> <pre><code>@abstractmethod\ndef get_value(self) -&gt; Any:\n\"\"\"Calculate the value of the observable.\n    Implement this method to define a new observable. Here're common cases:\n    1. Quick calculation: use `self.event` to get physics objects and write\n    the calculation directly.\n    2. Take the advantage of Observable: use `self.objects` to do the\n    calculation.\n    Return None if the observable is not correctly got.\n    \"\"\"\n...  # pragma: no cover\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.parse_shortcut","title":"parse_shortcut","text":"<pre><code>parse_shortcut(shortcut)\n</code></pre> <p>Parse the shortcut to get the object pairs.</p> Source code in <code>hml/observables.py</code> <pre><code>def parse_shortcut(self, shortcut: str) -&gt; list[tuple[str, int | None]]:\n\"\"\"Parse the shortcut to get the object pairs.\"\"\"\nobject_pairs = []\nobjects = shortcut.split(self.separate_objects)\nfor obj in objects:\nif \"_\" in obj:\nbranch_name, index = obj.split(self.seprate_branch_name_and_index)\nindex = int(index)\nelse:\nbranch_name, index = obj, None\nobject_pairs.append((branch_name, index))\nreturn object_pairs\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.build_shortcut","title":"build_shortcut","text":"<pre><code>build_shortcut(object_pairs)\n</code></pre> <p>Build the shortcut from the object pairs.</p> Source code in <code>hml/observables.py</code> <pre><code>def build_shortcut(self, object_pairs: list[tuple[str, int | None]]) -&gt; str:\n\"\"\"Build the shortcut from the object pairs.\"\"\"\nshortcuts = []\nfor branch_name, index in object_pairs:\nif index is not None:\nobj = f\"{branch_name}{self.seprate_branch_name_and_index}{index}\"\nelse:\nobj = branch_name\nshortcuts.append(obj)\nreturn self.separate_objects.join(shortcuts)\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Observable.add_alias","title":"add_alias  <code>classmethod</code>","text":"<pre><code>add_alias(*alias)\n</code></pre> <p>Add alias for the class name.</p> Source code in <code>hml/observables.py</code> <pre><code>@classmethod\ndef add_alias(cls, *alias: str) -&gt; None:\n\"\"\"Add alias for the class name.\"\"\"\nfor i in alias:\nObservable.all_observables[i] = cls\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Px","title":"Px","text":"<p>             Bases: <code>Observable</code></p> <p>Get the x component of the momentum.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.Px</code> is the x component of the momentum of the leading jet. - <code>Jet.Px</code> is the x component of the momentum of all jets.</p> <p>Alias: px</p> Source code in <code>hml/observables.py</code> <pre><code>class Px(Observable):\n\"\"\"Get the x component of the momentum.\n    Available for single and multiple objects. For example:\n    - `Jet_0.Px` is the x component of the momentum of the leading jet.\n    - `Jet.Px` is the x component of the momentum of all jets.\n    Alias: px\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().Px() for i in obj]\nelse:\nreturn obj.P4().Px()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Py","title":"Py","text":"<p>             Bases: <code>Observable</code></p> <p>Get the y component of the momentum.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.Py</code> is the y component of the momentum of the leading jet. - <code>Jet.Py</code> is the y component of the momentum of all jets.</p> <p>Alias: py</p> Source code in <code>hml/observables.py</code> <pre><code>class Py(Observable):\n\"\"\"Get the y component of the momentum.\n    Available for single and multiple objects. For example:\n    - `Jet_0.Py` is the y component of the momentum of the leading jet.\n    - `Jet.Py` is the y component of the momentum of all jets.\n    Alias: py\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().Py() for i in obj]\nelse:\nreturn obj.P4().Py()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Pz","title":"Pz","text":"<p>             Bases: <code>Observable</code></p> <p>Get the z component of the momentum.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.Pz</code> is the z component of the momentum of the leading jet. - <code>Jet.Pz</code> is the z component of the momentum of all jets.</p> <p>Alias: pz</p> Source code in <code>hml/observables.py</code> <pre><code>class Pz(Observable):\n\"\"\"Get the z component of the momentum.\n    Available for single and multiple objects. For example:\n    - `Jet_0.Pz` is the z component of the momentum of the leading jet.\n    - `Jet.Pz` is the z component of the momentum of all jets.\n    Alias: pz\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().Pz() for i in obj]\nelse:\nreturn obj.P4().Pz()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.E","title":"E","text":"<p>             Bases: <code>Observable</code></p> <p>Get the energy of the object.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.E</code> is the energy of the leading jet. - <code>Jet.E</code> is the energy of all jets.</p> <p>Alias: e, Energy</p> Source code in <code>hml/observables.py</code> <pre><code>class E(Observable):\n\"\"\"Get the energy of the object.\n    Available for single and multiple objects. For example:\n    - `Jet_0.E` is the energy of the leading jet.\n    - `Jet.E` is the energy of all jets.\n    Alias: e, Energy\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().E() for i in obj]\nelse:\nreturn obj.P4().E()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Pt","title":"Pt","text":"<p>             Bases: <code>Observable</code></p> <p>Get the transverse momentum of the object.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.Pt</code> is the transverse momentum of the leading jet. - <code>Jet.Pt</code> is the transverse momentum of all jets.</p> <p>Alias: pt, pT, PT</p> Source code in <code>hml/observables.py</code> <pre><code>class Pt(Observable):\n\"\"\"Get the transverse momentum of the object.\n    Available for single and multiple objects. For example:\n    - `Jet_0.Pt` is the transverse momentum of the leading jet.\n    - `Jet.Pt` is the transverse momentum of all jets.\n    Alias: pt, pT, PT\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().Pt() for i in obj]\nelse:\nreturn obj.P4().Pt()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Eta","title":"Eta","text":"<p>             Bases: <code>Observable</code></p> <p>Get the pseudorapidity of the object.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.Eta</code> is the pseudorapidity of the leading jet. - <code>Jet.Eta</code> is the pseudorapidity of all jets.</p> <p>Alias: eta</p> Source code in <code>hml/observables.py</code> <pre><code>class Eta(Observable):\n\"\"\"Get the pseudorapidity of the object.\n    Available for single and multiple objects. For example:\n    - `Jet_0.Eta` is the pseudorapidity of the leading jet.\n    - `Jet.Eta` is the pseudorapidity of all jets.\n    Alias: eta\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().Eta() for i in obj]\nelse:\nreturn obj.P4().Eta()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Phi","title":"Phi","text":"<p>             Bases: <code>Observable</code></p> <p>Get the azimuthal angle of the object.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.Phi</code> is the azimuthal angle of the leading jet. - <code>Jet.Phi</code> is the azimuthal angle of all jets.</p> <p>Alias: phi</p> Source code in <code>hml/observables.py</code> <pre><code>class Phi(Observable):\n\"\"\"Get the azimuthal angle of the object.\n    Available for single and multiple objects. For example:\n    - `Jet_0.Phi` is the azimuthal angle of the leading jet.\n    - `Jet.Phi` is the azimuthal angle of all jets.\n    Alias: phi\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().Phi() for i in obj]\nelse:\nreturn obj.P4().Phi()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.M","title":"M","text":"<p>             Bases: <code>Observable</code></p> <p>Get the mass of the object.</p> <p>Available for single and multiple objects. For example: - <code>Jet_0.M</code> is the mass of the leading jet. - <code>Jet.M</code> is the mass of all jets.</p> <p>Alias: m, mass, Mass</p> Source code in <code>hml/observables.py</code> <pre><code>class M(Observable):\n\"\"\"Get the mass of the object.\n    Available for single and multiple objects. For example:\n    - `Jet_0.M` is the mass of the leading jet.\n    - `Jet.M` is the mass of all jets.\n    Alias: m, mass, Mass\"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.P4().M() for i in obj]\nelse:\nreturn obj.P4().M()\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.DeltaR","title":"DeltaR","text":"<p>             Bases: <code>Observable</code></p> <p>Calculate the deltaR between two objects.</p> <p>Available for two objects. For example: - <code>Jet_0-Jet_1.DeltaR</code> is the deltaR between the leading two jets. - <code>Jet_0-Jet.DeltaR</code> is the deltaR between the leading jet and all jets. - <code>Jet-Jet.DeltaR</code> is the deltaR between all jets.</p> Source code in <code>hml/observables.py</code> <pre><code>class DeltaR(Observable):\n\"\"\"Calculate the deltaR between two objects.\n    Available for two objects. For example:\n    - `Jet_0-Jet_1.DeltaR` is the deltaR between the leading two jets.\n    - `Jet_0-Jet.DeltaR` is the deltaR between the leading jet and all jets.\n    - `Jet-Jet.DeltaR` is the deltaR between all jets.\n    \"\"\"\ndef get_value(self) -&gt; Any:\nif len(self.objects) != 2:\nreturn\nobj1, obj2 = self.objects\nobj1 = [obj1] if not isinstance(obj1, list) else obj1\nobj2 = [obj2] if not isinstance(obj2, list) else obj2\ndistances = []\nfor i, j in product(obj1, obj2):\ndistances.append(i.P4().DeltaR(j.P4()))\nreturn distances[0] if len(distances) == 1 else distances\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.NSubjettiness","title":"NSubjettiness","text":"<p>             Bases: <code>Observable</code></p> <p>Get the n-subjettiness from the leaf Tau of the branch FatJet.</p> <p>Available for single FatJet objects. For example: - <code>FatJet_0.NSubjettiness</code> is the tau1 (by default) of the leading FatJet.</p> <p>Alias: TauN</p> Source code in <code>hml/observables.py</code> <pre><code>class NSubjettiness(Observable):\n\"\"\"Get the n-subjettiness from the leaf Tau of the branch FatJet.\n    Available for single FatJet objects. For example:\n    - `FatJet_0.NSubjettiness` is the tau1 (by default) of the leading FatJet.\n    Alias: TauN\n    \"\"\"\ndef __init__(\nself,\nshortcut: str | None = None,\nobject_pairs: list[tuple[str, int | None]] | None = None,\nn: int = 1,\n) -&gt; None:\nsuper().__init__(shortcut, object_pairs)\nself.n = n\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.Tau[self.n - 1] for i in obj]\nelse:\nreturn obj.Tau[self.n - 1]\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.NSubjettinessRatio","title":"NSubjettinessRatio","text":"<p>             Bases: <code>Observable</code></p> <p>Calculate the n-subjettiness ratio from the leaf Tau of the branch FatJet.</p> <p>Available for single FatJet objects. For example: - <code>FatJet_0.NSubjettinessRatio</code> is the tau21 (by default) of the leading FatJet.</p> <p>Alias: TauMN</p> Source code in <code>hml/observables.py</code> <pre><code>class NSubjettinessRatio(Observable):\n\"\"\"Calculate the n-subjettiness ratio from the leaf Tau of the branch FatJet.\n    Available for single FatJet objects. For example:\n    - `FatJet_0.NSubjettinessRatio` is the tau21 (by default) of the leading\n    FatJet.\n    Alias: TauMN\n    \"\"\"\ndef __init__(\nself,\nshortcut: str | None = None,\nobject_pairs: list[tuple[str, int | None]] | None = None,\nm: int = 2,\nn: int = 1,\n) -&gt; None:\nsuper().__init__(shortcut, object_pairs)\nself.m = m\nself.n = n\ndef get_value(self) -&gt; Any:\nif len(self.objects) == 0:\nreturn\nobj = self.objects[0]\nif isinstance(obj, list):\nreturn [i.Tau[self.m - 1] / i.Tau[self.n - 1] for i in obj]\nelse:\nreturn obj.Tau[self.m - 1] / obj.Tau[self.n - 1]\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.Size","title":"Size","text":"<p>             Bases: <code>Observable</code></p> <p>The number of physics objects.</p> <p>Available for single object. For example: - <code>Jet.Size</code> is the number of jets.</p> <p>Alias: size</p> Source code in <code>hml/observables.py</code> <pre><code>class Size(Observable):\n\"\"\"The number of physics objects.\n    Available for single object. For example:\n    - `Jet.Size` is the number of jets.\n    Alias: size\n    \"\"\"\ndef get_value(self):\nif len(self.objects) &gt; 0:\nreturn len(self.objects[0])\n</code></pre>"},{"location":"api-reference/hml.observables/#hml.observables.get_observable","title":"get_observable","text":"<pre><code>get_observable(name, **kwargs)\n</code></pre> <p>Get an observable from its name.</p> <p>An observable name is composed of two parts: the shortcut and the class name. For example, <code>Jet_0.Pt</code> is the name of the <code>Pt</code> observable of the first jet, in which <code>Jet_0</code> is the shortcut and <code>Pt</code> is the class name.</p> Source code in <code>hml/observables.py</code> <pre><code>def get_observable(name: str, **kwargs) -&gt; Observable:\n\"\"\"Get an observable from its name.\n    An observable name is composed of two parts: the shortcut and the class name.\n    For example, `Jet_0.Pt` is the name of the `Pt` observable of the first jet,\n    in which `Jet_0` is the shortcut and `Pt` is the class name.\n    \"\"\"\nif len(parts := name.split(\".\")) == 1:\nshortcut, classname = \"\", parts[0]\nelse:\nshortcut, classname = parts\nif classname not in Observable.all_observables:\nraise ValueError(f\"Observable {classname} not found\")\nreturn Observable.all_observables[classname](shortcut, **kwargs)\n</code></pre>"},{"location":"api-reference/hml.representations/","title":"hml.representations","text":""},{"location":"api-reference/hml.representations/#hml.representations.Set","title":"Set","text":"<p>A set of observables.</p> <p>Set is a 1D representation of an event. It contains a list of observables. It is usually used as input to approaches like CutAndCount and ToyMultilayerPerceptron (MLP).</p> PARAMETER  DESCRIPTION <code>observables</code> <p>A list of observables or their names.</p> <p> TYPE: <code>list[Observable | str]</code> </p> Source code in <code>hml/representations.py</code> <pre><code>class Set:\n\"\"\"A set of observables.\n    Set is a 1D representation of an event. It contains a list of observables.\n    It is usually used as input to approaches like CutAndCount and\n    ToyMultilayerPerceptron (MLP).\n    Parameters\n    ----------\n    observables : list[Observable | str]\n        A list of observables or their names.\n    \"\"\"\ndef __init__(self, observables: list[Observable | str]) -&gt; None:\nself.observables = []\nfor obs in observables:\nif isinstance(obs, Observable):\nself.observables.append(obs)\nelse:\nself.observables.append(get_observable(obs))\nself.names = [obs.name for obs in self.observables]\nself.values = []\ndef read_event(self, event) -&gt; None:\nfor obs in self.observables:\nobs.read_event(event)\nself.values.append([obs.value for obs in self.observables])\ndef to_numpy(self, dtype=np.float32) -&gt; np.ndarray:\nreturn np.array(self.values, dtype=dtype)\ndef to_pandas(self) -&gt; pd.DataFrame:\nreturn pd.DataFrame(self.values, columns=self.names)\n</code></pre>"},{"location":"api-reference/hml.utils/","title":"hml.utils","text":""},{"location":"api-reference/hml.utils/#hml.utils.Filter","title":"Filter","text":"<p>Pre-select events based on a list of cuts.</p> PARAMETER  DESCRIPTION <code>cuts</code> <p>The list of cuts to apply.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>hml/utils.py</code> <pre><code>class Filter:\n\"\"\"Pre-select events based on a list of cuts.\n    Parameters\n    ----------\n    cuts : list[str]\n        The list of cuts to apply.\n    \"\"\"\ndef __init__(self, cuts: list[str]) -&gt; None:\nself.cuts = cuts\nself.stat = OrderedDict({cut: 0 for cut in cuts})\ndef read_event(self, event):\n\"\"\"Read the event from a TTree.\"\"\"\nself.event = event\nreturn self\ndef passed(self):\n\"\"\"Check if the event passed the cuts.\"\"\"\ndef _replace_with_value(match):\n\"\"\"Replace the string name of an observable with its value.\"\"\"\nobservable_name = match.group(0)  # complete match\nvalue = get_observable(observable_name).read_event(self.event).value\nif value is not None:\nreturn str(value)\nelse:\nreturn \"float('nan')\"\nfor cut in self.cuts:\nmodified_string = re.sub(\nr\"\\b(?!\\d+\\b)([\\w\\d_]+)\\.([\\w\\d_]+)\\b\", _replace_with_value, cut\n)\nif eval(modified_string) is False:\nself.stat[cut] += 1\nreturn False\nreturn True\n</code></pre>"},{"location":"api-reference/hml.utils/#hml.utils.Filter.read_event","title":"read_event","text":"<pre><code>read_event(event)\n</code></pre> <p>Read the event from a TTree.</p> Source code in <code>hml/utils.py</code> <pre><code>def read_event(self, event):\n\"\"\"Read the event from a TTree.\"\"\"\nself.event = event\nreturn self\n</code></pre>"},{"location":"api-reference/hml.utils/#hml.utils.Filter.passed","title":"passed","text":"<pre><code>passed()\n</code></pre> <p>Check if the event passed the cuts.</p> Source code in <code>hml/utils.py</code> <pre><code>def passed(self):\n\"\"\"Check if the event passed the cuts.\"\"\"\ndef _replace_with_value(match):\n\"\"\"Replace the string name of an observable with its value.\"\"\"\nobservable_name = match.group(0)  # complete match\nvalue = get_observable(observable_name).read_event(self.event).value\nif value is not None:\nreturn str(value)\nelse:\nreturn \"float('nan')\"\nfor cut in self.cuts:\nmodified_string = re.sub(\nr\"\\b(?!\\d+\\b)([\\w\\d_]+)\\.([\\w\\d_]+)\\b\", _replace_with_value, cut\n)\nif eval(modified_string) is False:\nself.stat[cut] += 1\nreturn False\nreturn True\n</code></pre>"},{"location":"api-reference/hml.approaches/cuts/","title":"Cuts","text":""},{"location":"api-reference/hml.approaches/trees/","title":"Trees","text":""},{"location":"api-reference/hml.approaches/networks/mlps/","title":"MLP","text":""},{"location":"examples/01_generate_events/","title":"Generate events","text":"<p>This guide shows how to use the Madgraph5 class of HML to generate events from Z boson and QCD to dijets processes. To get started, let\u2019s import some necessary classes from <code>generators</code> module:</p> <pre><code>from hml.generators import Madgraph5, Madgraph5MultiRun, Madgraph5Run\n</code></pre> <pre><code>Welcome to JupyROOT 6.24/02\n</code></pre>"},{"location":"examples/01_generate_events/#initialization","title":"Initialization","text":"<p>The Madgraph5 API (application programming interface) provided by HML works similarly to the Madgraph5 CLI (command line interface): initialization corresponds to the classic workflow of <code>generate, output, launch</code>.</p> <pre><code>zjj = Madgraph5(\nexecutable=\"mg5_aMC\",\nmodel=\"sm\",\ndefinitions={},\nprocesses=[\"p p &gt; z z, z &gt; j j, z &gt; vl vl~\"],\noutput=\"data/pp2zz_z2jj_z2vlvl\",\n)\n</code></pre> <ul> <li><code>executable</code> refers to the path of the <code>mg5_aMC</code> executable file.</li> <li><code>model</code> is managed by Madgraph5 itself.</li> <li><code>definitions</code> are used for the <code>define</code> command in Madgraph5.</li> <li>Usually in Madgraph5, you need to use <code>generate</code> and <code>add process</code> to create multiple processes. In HML, processes are represented as a list of strings.</li> <li>If <code>output</code> already exists, this class will not generate processes again.</li> </ul>"},{"location":"examples/01_generate_events/#launch-the-first-run","title":"Launch the first run","text":"<p>After initializing the class (or <code>output</code> in Madgraph5 CLI), you can now launch a new run:</p> <pre><code>zjj.launch(\nshower=\"pythia8\",\ndetector=\"delphes\",\nsettings={\"iseed\": 42, \"nevents\": 1000, \"htjmin\": 400},\n)\n</code></pre> <pre><code>Running Survey\nRunning Pythia8\nRunning Delphes\nStoring files\n\nDone\n</code></pre> <ul> <li><code>shower</code> and <code>detector</code> are options for parton shower and detector simulation tools. Currently, <code>pythia8</code> and <code>delphes</code> are available.</li> <li>In Madgraph5, you can use the <code>set</code> command to change configurations in different cards without opening them. The <code>settings</code> attribute contains these configurations as a Python dictionary.</li> <li>To generate a large number of events, set the <code>multi_run</code> parameter.</li> </ul>"},{"location":"examples/01_generate_events/#check-the-information","title":"Check the information","text":"<p>After the generation is finished, you can use <code>.summary()</code> to check all the information of runs:</p> <pre><code>zjj.summary()\n</code></pre> <pre>                 p p &gt; z z, z &gt; j j, z &gt; vl vl~                 \n\u250f\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 # \u2503 Name      \u2503 Tag   \u2503 Cross section (pb) \u2503 N events \u2503 Seed \u2503\n\u2521\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 0 \u2502 run_01[1] \u2502 tag_1 \u2502     2.273e-03      \u2502    1,000 \u2502   42 \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            Output:                             \n/root/workspace_ssd/projects/hep-ml-lab/examples/data/pp2zz_z2jj\n                            _z2vlvl                             \n</pre> <ul> <li>The number in the square bracket after \u201crun_01\u201d represents the value of <code>multi_run</code>.</li> <li>A random seed is crucial to reproduce the results, which is why <code>Seed</code> is also displayed.</li> </ul> <p>The data in the summary table are properties of a run:</p> <pre><code>run_01 = zjj.runs[0]\nprint(\"Name:\", run_01.name)\nprint(\"N Subruns:\", len(run_01.runs))\nprint(\"Tag:\", run_01.tag)\nprint(\"Cross section:\", run_01.cross_section)\nprint(\"N events:\", run_01.n_events)\nprint(\"Seed:\", run_01.seed)\n</code></pre> <pre><code>Name: run_01\nN Subruns: 1\nTag: tag_1\nCross section: 0.0022735\nN events: 1000\nSeed: 42\n</code></pre> <p>You can access the <code>events</code> attribute to read the root file from Delphes:</p> <pre><code>for event in run.events:\nprint(f\"n_jets: {event.Jet_size}\")\nprint(f\"n_fat_jets: {event.FatJet_size}\")\nbreak\n</code></pre> <pre><code>n_jets: 2\nn_fat_jets: 1\n</code></pre>"},{"location":"examples/01_generate_events/#launch-the-second-run-similarly","title":"Launch the second run similarly","text":"<p>To build a signal vs background binary classification task, we need to generate QCD events without the intermediate Z boson.</p> <pre><code>qcd = Madgraph5(\nprocesses=['p p &gt; j j / z'],\noutput=\"./data/qcd\"\n)\nqcd.launch(\nshower=\"pythia8\",\ndetector=\"delphes\",\nsettings={\"iseed\": 42, \"nevents\": 1000, \"htjmin\": 400},\n)\nqcd.summary()\n</code></pre> <pre><code>Running Survey\nRunning Pythia8\nRunning Delphes\nStoring files\n\nDone\n</code></pre> <pre>                         p p &gt; j j / z                          \n\u250f\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 # \u2503 Name      \u2503 Tag   \u2503 Cross section (pb) \u2503 N events \u2503 Seed \u2503\n\u2521\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 0 \u2502 run_01[1] \u2502 tag_1 \u2502     5.611e+04      \u2502    1,000 \u2502   42 \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            Output:                             \n   /root/workspace_ssd/projects/hep-ml-lab/examples/data/qcd    \n</pre>"},{"location":"examples/01_generate_events/#read-the-existing-output","title":"Read the existing output","text":"<p>HML can handle three cases:</p> <ol> <li> <p>Events are generated by HML:</p> <pre><code>Madgraph5.from_output(\"./data/qcd\")\n</code></pre> </li> <li> <p>Events are generated by the <code>multi_run</code> command from MadEvent:</p> <pre><code>Madgraph5MultiRun.from_name(\"run_01\", \"./data/qcd\")\n</code></pre> </li> <li> <p>Events are generated normally by the <code>launch</code> command from Madgraph5:</p> <pre><code>Madgraph5Run.from_directory(\"./data/qcd/Events/run_01_0\")\n</code></pre> </li> </ol> <p>Check the doc to learn more about <code>Madgraph5, Madgraph5MultiRun, Madgraph5Run</code>.</p>"},{"location":"examples/02_create_datasets/","title":"Create datasets","text":"<p>This guide demonstrates how to use HML and Observable to build a Representation and create a dataset for future use. With Observable, you can create and use observables not only with specific classes but also with simple strings.</p> <p>Start by importing the necessary modules:</p> <pre><code>from hml.generators import Madgraph5\nfrom hml.observables import get_observable\nfrom hml.representations import Set\nfrom hml.datasets import TabularDataset\nfrom hml.utils import Filter\nfrom keras.utils import Progbar\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code>Welcome to JupyROOT 6.24/02\n</code></pre>"},{"location":"examples/02_create_datasets/#load-generated-events","title":"Load generated events","text":"<p>As the previous guide showed, HML can handle three cases. Here, we use the <code>Madgraph5</code> class to fetch runs from the output directory:</p> <pre><code>zjj = Madgraph5.from_output(\"./data/pp2zz_z2jj_z2vlvl\")\nqcd = Madgraph5.from_output(\"./data/qcd\")\n</code></pre> <p>We'll use <code>.runs[0].events</code> to refer to the root file from Delphes in the event loop.</p>"},{"location":"examples/02_create_datasets/#preselection-and-representation","title":"Preselection and Representation","text":"<p>For the processes, we choose three observables: mass and n-subjettiness ratio of the leading fat jet, and the angular distance between the leading and subleading jets. To ensure we can obtain the observables, it\u2019s necessary to preselect or filter events based on the number of fat jets and jets:</p> <pre><code>preselections = Filter([\"FatJet.Size &gt; 0\", \"Jet.Size &gt; 1\"])\n</code></pre> <ul> <li><code>FatJet.Size</code> is the observable <code>Size</code> associated with the physics object <code>FatJet</code>. This observable refers to a collection of objects. In a root file, it applies to an entire branch. The physics object corresponds to the branch name.</li> <li>An observable is always linked to one or more physics objects. This concept inspired HML to create its own observable parsing system: <code>&lt;physics_object&gt;-&lt;another&gt;.&lt;observable&gt;</code>. The <code>physics_object</code> is any branch defined in your root file. Multiple objects are separated by <code>-</code>. For a single object, specify the index with <code>_</code>, for example, <code>Jet_0</code>, <code>Muon_1</code>, and so on.</li> </ul> <p>Now, we use the 1D data container <code>Set</code> to hold these three observables for all events:</p> <pre><code>zjj_set = Set(\n[\nget_observable(\"FatJet_0.Mass\"),\nget_observable(\"FatJet_0.TauMN\", m=2, n=1),\nget_observable(\"Jet_0-Jet_1.DeltaR\"),\n]\n)\nqcd_set = Set(\n[\nget_observable(\"FatJet_0.Mass\"),\nget_observable(\"FatJet_0.TauMN\", m=2, n=1),\nget_observable(\"Jet_0-Jet_1.DeltaR\"),\n]\n)\n</code></pre> <ul> <li>The pattern mentioned above can fetch an observable class anonymously.</li> <li>Each observable has several aliases: for instance, <code>TauMN</code> is an alias for <code>NSubjettinessRatio</code>, <code>pt, pT, PT</code> is an alias for <code>Pt</code>.</li> <li>Fetch observables with an external parameter to initialize them correctly.</li> </ul>"},{"location":"examples/02_create_datasets/#event-loop","title":"Event loop","text":"<p>Next, we loop over the events, preselect the valid ones and prepare data in <code>Set</code>:</p> <pre><code>zjj_bar = Progbar(zjj.runs[0].n_events)\nfor i, event in enumerate(zjj.runs[0].events):\nif preselections.read_event(event).passed():\nzjj_set.read_event(event)\nzjj_bar.update(i+1)\nqcd_bar = Progbar(qcd.runs[0].n_events)\nfor i, event in enumerate(qcd.runs[0].events):\nif preselections.read_event(event).passed():\nqcd_set.read_event(event)\nqcd_bar.update(i+1)\n</code></pre> <pre><code>1000/1000 [==============================] - 1s 889us/step\n1000/1000 [==============================] - 1s 1ms/step\n</code></pre> <p>To confirm our choice of observables is powerful enough to differentiate the signal and background, we plot three distributions:</p> <pre><code>fig, axs = plt.subplots(1, 3, figsize=(15, 5))\naxs[0].hist(zjj_set.to_numpy()[:, 0], alpha=0.5, label=\"Z -&gt; jj\")\naxs[0].hist(qcd_set.to_numpy()[:, 0], alpha=0.5, label=\"QCD dijets\")\naxs[0].set_title(zjj_set.names[0])\naxs[1].hist(zjj_set.to_numpy()[:, 1], alpha=0.5, label=\"Z -&gt; jj\")\naxs[1].hist(qcd_set.to_numpy()[:, 1], alpha=0.5, label=\"QCD dijets\")\naxs[1].set_title(zjj_set.names[1])\naxs[2].hist(zjj_set.to_numpy()[:, 2], alpha=0.5, label=\"Z -&gt; jj\")\naxs[2].hist(qcd_set.to_numpy()[:, 2], alpha=0.5, label=\"QCD dijets\")\naxs[2].set_title(zjj_set.names[2])\naxs[2].legend()\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/02_create_datasets/#pack-things-up","title":"Pack things up","text":"<p>Lastly, we create our dataset:</p> <pre><code>samples = np.array(zjj_set.values + qcd_set.values, \"float32\")\ntargets = np.array([1] * len(zjj_set.values) + [0] * len(qcd_set.values), \"int32\")\ndataset = TabularDataset(\nsamples=samples,\ntargets=targets,\nfeature_names=zjj_set.names,\ntarget_names=[\"Z -&gt; jj\", \"QCD dijets\"],\ndescription=\"Z -&gt; jj vs QCD dijets\",\n)\ndataset.save(\"./data/zjj_vs_qcd\")\n</code></pre> <ul> <li><code>samples</code> represent all data points, while <code>targets</code> represent the integer number assigned to each class.</li> <li>Utilize <code>feature_names</code> and <code>target_names</code> to enhance the readability of your data.</li> <li>Include a brief <code>description</code> for your dataset.</li> </ul> <p>Check the doc to learn more about observables, representations and datasets.</p>"},{"location":"examples/03_apply_approaches/","title":"Applying Approaches","text":"<p>This guide shows how to use the three built-in approaches to differentiate signal and background. HML streamlines the application of different approaches by adapting them in Keras-style (compile, fit, predict), which is simple to use.</p> <p>Let's get started by importing the necessary modules:</p> <pre><code># Dataset\nfrom hml.datasets import load_dataset\nfrom sklearn.model_selection import train_test_split\n# Approaches\nfrom hml.approaches import CutAndCount as CBA\nfrom hml.approaches import GradientBoostedDecisionTree as BDT\nfrom hml.approaches import ToyMultilayerPerceptron as MLP\n# Evaluation\nfrom keras.metrics import Accuracy, AUC\nfrom sklearn.metrics import roc_curve\nfrom hml.metrics import MaxSignificance, RejectionAtEfficiency\nfrom collections import defaultdict\nfrom tabulate import tabulate\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Save and load\nfrom hml.approaches import load_approach\n</code></pre>"},{"location":"examples/03_apply_approaches/#loading-the-dataset","title":"Loading the Dataset","text":"<p><code>load_dataset</code> works similarly to <code>get_observable</code> \u2014 users do not need to know the specific class name for that dataset to use it:</p> <pre><code>dataset = load_dataset(\"./data/zjj_vs_qcd.npz\")\n</code></pre> <p>To split the whole dataset, use its properties <code>samples</code> and <code>targets</code>:</p> <pre><code>x_train, x_test, y_train, y_test = train_test_split(\ndataset.samples, dataset.targets, test_size=0.3, random_state=42\n)\nx_train, x_val, y_train, y_val = train_test_split(\nx_train, y_train, test_size=0.2, random_state=42\n)\n</code></pre>"},{"location":"examples/03_apply_approaches/#cut-and-count-approach","title":"Cut and Count Approach","text":"<p>The cut-based analysis or cut and count approach is one of fundamental approaches widely used in HEP phenomenology . We implement it in Keras framework:</p> <pre><code>approach1 = CBA()\napproach1.compile(\noptimizer=\"adam\",\nloss=\"sparse_categorical_crossentropy\",\nmetrics=[\"accuracy\"],\n)\nhistory = approach1.fit(\nx_train,\ny_train,\nbatch_size=len(x_train),\nvalidation_data=(x_val, y_val),\n)\n</code></pre> <pre><code>1/1 [==============================] - 2s 2s/step - loss: 4.0295 - accuracy: 0.7500 - val_loss: 4.9923 - val_accuracy: 0.6903\n</code></pre> <ul> <li>The <code>optimizer</code> in <code>compile</code> has no effect for CutAndCount because there are no learnable parameters.</li> <li>The <code>batch_size</code> is preferably the whole training set to show the complete distributions of observables. The <code>epochs</code> has no effect.</li> </ul>"},{"location":"examples/03_apply_approaches/#boosted-decision-tree","title":"Boosted Decision Tree","text":"<p>We adapt <code>GradientBoostingClassifier</code> from <code>sklearn</code> to work as a <code>Keras</code> model:</p> <pre><code>approach2 = BDT()\napproach2.compile(\nmetrics=[\"accuracy\"],\n)\nhistory = approach2.fit(\nx_train,\ny_train,\nvalidation_data=(x_val, y_val),\n)\n</code></pre> <pre><code>100/100 [==============================] - 1s 8ms/step - loss: 0.4396 - accuracy: 0.9239 - val_loss: 1.2479 - val_accuracy: 0.5841\n</code></pre> <ul> <li>The <code>optimizer</code> and <code>loss</code> have any effect in <code>compile</code> because <code>sklearn</code> will handle them internally.</li> <li><code>batch_size</code> and <code>epochs</code> are irrelevant for a tree.</li> <li>The progress bar displays the number of estimators rather than training steps.</li> </ul>"},{"location":"examples/03_apply_approaches/#networks","title":"Networks","text":"<p>Currently, HML provides a toy multi-layer perceptron to perform simple analysis:</p> <pre><code>approach3 = MLP()\napproach3.compile(\nloss=\"sparse_categorical_crossentropy\",\nmetrics=[\"accuracy\"],\n)\napproach3.fit(\nx_train,\ny_train,\nbatch_size=128,\nepochs=20,\nvalidation_data=(x_val, y_val),\n)\n</code></pre> <pre><code>Epoch 1/20\n8/8 [==============================] - 1s 34ms/step - loss: 13.7174 - accuracy: 0.5575 - val_loss: 10.6973 - val_accuracy: 0.5841\nEpoch 2/20\n8/8 [==============================] - 0s 19ms/step - loss: 10.3071 - accuracy: 0.5575 - val_loss: 8.0258 - val_accuracy: 0.5841\nEpoch 3/20\n8/8 [==============================] - 0s 19ms/step - loss: 7.5906 - accuracy: 0.5575 - val_loss: 5.7093 - val_accuracy: 0.5841\nEpoch 4/20\n8/8 [==============================] - 0s 21ms/step - loss: 5.1318 - accuracy: 0.5575 - val_loss: 3.5278 - val_accuracy: 0.5841\nEpoch 5/20\n8/8 [==============================] - 0s 19ms/step - loss: 2.8022 - accuracy: 0.5575 - val_loss: 1.2921 - val_accuracy: 0.5841\nEpoch 6/20\n8/8 [==============================] - 0s 22ms/step - loss: 0.8136 - accuracy: 0.6217 - val_loss: 0.5321 - val_accuracy: 0.8540\nEpoch 7/20\n8/8 [==============================] - 0s 19ms/step - loss: 0.4860 - accuracy: 0.8662 - val_loss: 0.5465 - val_accuracy: 0.7611\nEpoch 8/20\n8/8 [==============================] - 0s 20ms/step - loss: 0.4802 - accuracy: 0.8496 - val_loss: 0.5843 - val_accuracy: 0.7257\nEpoch 9/20\n8/8 [==============================] - 0s 19ms/step - loss: 0.4749 - accuracy: 0.8473 - val_loss: 0.6016 - val_accuracy: 0.6372\nEpoch 10/20\n8/8 [==============================] - 0s 22ms/step - loss: 0.4863 - accuracy: 0.8341 - val_loss: 0.5898 - val_accuracy: 0.7168\nEpoch 11/20\n8/8 [==============================] - 0s 19ms/step - loss: 0.4621 - accuracy: 0.8451 - val_loss: 0.5200 - val_accuracy: 0.7080\nEpoch 12/20\n8/8 [==============================] - 0s 19ms/step - loss: 0.4600 - accuracy: 0.8507 - val_loss: 0.6299 - val_accuracy: 0.7080\nEpoch 13/20\n8/8 [==============================] - 0s 20ms/step - loss: 0.4609 - accuracy: 0.8451 - val_loss: 0.5236 - val_accuracy: 0.7965\nEpoch 14/20\n8/8 [==============================] - 0s 22ms/step - loss: 0.4423 - accuracy: 0.8540 - val_loss: 0.5849 - val_accuracy: 0.7389\nEpoch 15/20\n8/8 [==============================] - 0s 20ms/step - loss: 0.4510 - accuracy: 0.8485 - val_loss: 0.4898 - val_accuracy: 0.8407\nEpoch 16/20\n8/8 [==============================] - 0s 20ms/step - loss: 0.4401 - accuracy: 0.8584 - val_loss: 0.4997 - val_accuracy: 0.8186\nEpoch 17/20\n8/8 [==============================] - 0s 20ms/step - loss: 0.4364 - accuracy: 0.8529 - val_loss: 0.5946 - val_accuracy: 0.7389\nEpoch 18/20\n8/8 [==============================] - 0s 20ms/step - loss: 0.4432 - accuracy: 0.8429 - val_loss: 0.4955 - val_accuracy: 0.8186\nEpoch 19/20\n8/8 [==============================] - 0s 20ms/step - loss: 0.4246 - accuracy: 0.8518 - val_loss: 0.4807 - val_accuracy: 0.8496\nEpoch 20/20\n8/8 [==============================] - 0s 19ms/step - loss: 0.4228 - accuracy: 0.8418 - val_loss: 0.6476 - val_accuracy: 0.6283\n</code></pre>"},{"location":"examples/03_apply_approaches/#evaluation","title":"Evaluation","text":"<p>To benchmark these approaches, we use:</p> <ul> <li><code>Accuracy</code> and <code>Auc</code> to show overall performance;</li> <li><code>roc_curve</code> to display tradeoff between thresholds and performance;</li> <li><code>MaxSignificance</code> and <code>RejectionAtEfficiency</code>, crucial ones in phenomenology studies.</li> </ul> <pre><code>benchmark = defaultdict(list)\nfor approach in [approach1, approach2, approach3]:\ny_prob = approach.predict(x_test, verbose=0)\ny_pred = y_prob.argmax(axis=1)\nbenchmark[\"Name\"].append(approach.name)\nbenchmark[\"ACC\"].append(Accuracy()(y_test, y_pred).numpy())\nbenchmark[\"AUC\"].append(AUC()(y_test, y_prob[:, 1]).numpy())\nbenchmark[\"MaxSignificance\"].append(MaxSignificance()(y_test, y_prob[:, 1]).numpy())\nbenchmark[\"RejectionAtEfficiency\"].append(RejectionAtEfficiency(0.5)(y_test, y_prob[:, 1]).numpy())\nfpr, tpr, _ = roc_curve(y_test, y_prob[:, 1])\nplt.plot(fpr, tpr, label=f\"{approach.name}\")\nprint(tabulate(benchmark, headers=\"keys\", tablefmt=\"github\"))\nplt.title(\"ROC Curves\")\nplt.xlabel(\"Efficiency\")\nplt.ylabel(\"Mistag Rate\")\nplt.legend()\nplt.show()\n</code></pre> Name ACC AUC MaxSignificance RejectionAtEfficiency cut_and_count 0.729897 0.721404 10.1985 1 gradient_boosted_decision_tree 0.876289 0.93703 13.3053 125 toy_multilayer_perceptron 0.610309 0.915157 6.78387 249.999 <p></p>"},{"location":"examples/03_apply_approaches/#show-information","title":"Show Information","text":"<p>To clear show information of different Keras-based approaches, we use <code>summary</code>:</p> <pre><code>approach1.summary()\napproach2.summary()\napproach3.summary()\n</code></pre> <pre><code>Model: \"cut_and_count\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n=================================================================\nTotal params: 10 (40.00 Byte)\nTrainable params: 0 (0.00 Byte)\nNon-trainable params: 10 (40.00 Byte)\n_________________________________________________________________\nn_bins: 50\ncuts:\n  #1: x &gt;= 78.3743\n  #2: x &lt;= 0.5286\n  #3: x &lt;= 2.7339\nModel: \"gradient_boosted_decision_tree\"\n- ccp_alpha: 0\n- criterion: friedman_mse\n- init: None\n- learning_rate: 0.1\n- loss: log_loss\n- max_depth: 3\n- max_features: None\n- max_leaf_nodes: None\n- min_impurity_decrease: 0\n- min_samples_leaf: 1\n- min_samples_split: 2\n- min_weight_fraction_leaf: 0\n- n_estimators: 100\n- n_iter_no_change: None\n- name: gradient_boosted_decision_tree\n- random_state: None\n- subsample: 1\n- tol: 0.0001\n- validation_fraction: 0.1\n- verbose: 0\n- warm_start: False\nModel: \"toy_multilayer_perceptron\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n dense (Dense)               multiple                  40        \n\n dense_1 (Dense)             multiple                  110       \n\n dense_2 (Dense)             multiple                  22        \n\n=================================================================\nTotal params: 172 (688.00 Byte)\nTrainable params: 172 (688.00 Byte)\nNon-trainable params: 0 (0.00 Byte)\n_________________________________________________________________\n</code></pre> <p>Let\u2019s plot the cuts on distributions to show if it\u2019s fair enough:</p> <pre><code>fig, axs = plt.subplots(1, 3, figsize=(15, 5))\nfor index in range(x_train.shape[1]):\ncase = approach1.cases[index]\ncuts = approach1.cuts[index]\nobservable = dataset.feature_names[index]\nbin_edges = np.linspace(x_train[:, index].min(), x_train[:, index].max(), approach1.n_bins+1)\naxs[index].hist(x_test[:, index][y_test == 0], bins=bin_edges, alpha=0.5, label=\"0\")\naxs[index].hist(x_test[:, index][y_test == 1], bins=bin_edges, alpha=0.5, label=\"1\")\ny_min, y_max = axs[index].get_ylim()\naxs[index].vlines(bin_edges, y_min, y_max, color=\"k\", ls=\"dashed\", lw=0.5, label=\"bin edges\")\nif case == 0:\naxs[index].vlines(cuts[0], y_min, y_max, color=\"r\", label=f\"{observable} &lt;= {cuts[0]:.2f}\")\nelif case == 1:\naxs[index].vlines(cuts[0], y_min, y_max, color=\"r\", label=f\"{observable} &gt;= {cuts[0]:.2f}\")\nelif case == 2:\naxs[index].vlines(cuts[0], y_min, y_max, color=\"r\", label=f\"{cuts[0]:.2f} &lt;= {observable} &lt;= {cuts[1]:.2f}\")\naxs[index].vlines(cuts[1], y_min, y_max, color=\"r\")\nelse:\naxs[index].vlines(cuts[0], y_min, y_max, color=\"r\", label=f\"{observable} &lt;= {cuts[0]:.2f} or {observable} &gt;= {cuts[1]:.2f}\")\naxs[index].vlines(cuts[1], y_min, y_max, color=\"r\")\naxs[index].set_title(f\"{observable}\")\naxs[index].legend()\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/03_apply_approaches/#save-and-load-approaches","title":"Save and load approaches","text":"<p>After <code>fit</code> each approach, use <code>save</code> to save it to a file. To make folder structure clean, let\u2019s create a folder named \u201ccheckpoints\u201d first:</p> <pre><code>mkdir checkpoints\n</code></pre> <p>Then, in your codes or the notebook:</p> <pre><code>approach1.save(\"./checkpoints/CBA.keras\")\napproach2.save(\"./checkpoints/BDT.pickle\")\napproach3.save(\"./checkpoints/MLP.keras\")\n</code></pre> <p>Once again, we use <code>load_approach</code> to let HML decide which class it actually is, just like <code>get_observable</code>, <code>load_dataset</code>:</p> <pre><code>loaded_approach1 = load_approach(\"./checkpoints/CBA.keras\")\nloaded_approach2 = load_approach(\"./checkpoints/BDT.pickle\")\nloaded_approach3 = load_approach(\"./checkpoints/MLP.keras\")\nassert (approach1.cuts.numpy() == loaded_approach1.cuts.numpy()).all()\nassert approach2.n_estimators_ == loaded_approach2.n_estimators_\nassert approach3.count_params() == loaded_approach3.count_params()\n</code></pre> <p>Check the doc to learn more about cuts, trees, and networks.</p>"}]}